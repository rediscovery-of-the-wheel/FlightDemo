options {
  JAVA_UNICODE_ESCAPE = true;
  ERROR_REPORTING = true;
  DEBUG_PARSER = true;
  STATIC = false;
  JDK_VERSION = "1.6";
  MULTI=true;
  NODE_DEFAULT_VOID = true;
  VISITOR=true;
}

PARSER_BEGIN(ScriptParser)

package com.serenegiant.lang.script;
import android.util.Log;
import java.util.*;

public class ScriptParser {

	private static final String TAG = "ScriptParser";

	/** シンボルテーブル */
	private final java.util.Map<String, Object> symbols = new java.util.LinkedHashMap<String, Object>();

	/** 演算用のスタック */
	private Object[] stack = new Object[1024];
	private int top = -1;

	/* 演算用のスタックに値をプッシュ */
	public void push_op(Object op) {
		stack[++top] = op;
	}

	/* 演算用のスタックに値をプッシュ */
	public void push_op(int index, Object op) {
		top += index;
		stack[top] = op;
	}

	/* 演算用のスタックから値を取得 */
	public Object pop_op() {
		return stack[top--];
	}

	/* 演算用のスタックの上から指定した番号の値を取得(スタックからは取り出さない) */
	public Object peek_op(int index) {
		return stack[top + index];
	}

	/* シンボルを登録 */
	public void add_symbol(String symbol, Object value) {
		symbols.put(symbol, value);
	}

	/* シンボルに対応する値を取得, シンボルテーブルに存在しなければnull */
	public Object get_symbol(String symbol) {
		if (symbols.containsKey(symbol)) {
			return symbols.get(symbol);
		} else {
			return null;
		}
	}

	/* シンボルがシンボルテーブルに登録されているかどうかを取得 */
	public boolean symbol_exist(String symbol) {
		return symbols.containsKey(symbol);
	}

    /** typedefで宣言した型名保持用 */
    private final Set types = new HashSet();

    /** パーサーがtypedefの処理中かどうかを保持するため */
    private final Stack typedefParsingStack = new Stack();

    /** 指定した識別子がtypedefで定義した型名かどうかを返す */
    private boolean isType(String type){
		return types.contains(type);
    }

    /** typedef用に型名を追加 */
    private void addType(String type) {
		types.add(type);
    }

    /** typedefで定義した型名の一覧を出力 */
    private void printTypes(){
		for (Iterator i = types.iterator(); i.hasNext();) {
			System.out.println(i.next());
		}
    }

    // パーサーを生成
    public static ScriptParser createInstance(java.io.InputStream in) {
		final ScriptParser parser = new ScriptParser(in);
		// Hack to include type "special types"
	    parser.types.add("__signed__");
	    parser.types.add("__const");
	    parser.types.add("__inline__");
	    parser.types.add("__signed");
		return parser;
	}
}

PARSER_END(ScriptParser)

/** 空白 */
SKIP : {
	" " |
	"\t" |
	"\n" |
	"\r" |
	<"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")> |
	<"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/"> |
	"#" : PREPROCESSOR_OUTPUT
}

<PREPROCESSOR_OUTPUT> SKIP:
{
     "\n" : DEFAULT
}

<PREPROCESSOR_OUTPUT> MORE:
{
	"\\\n" |
	"\\\r\n" |
	< ~[] >
}


/** 数字/文字(列)定数用トークン */
TOKEN : {
	<INTEGER_LITERAL: <DECIMAL_LITERAL> (["l","L"])? | <HEX_LITERAL> (["l","L"])? | <OCTAL_LITERAL> (["l","L"])?> |
	<#DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])*> |
	<#HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+> |
	<#OCTAL_LITERAL: "0" (["0"-"7"])*> |
	<FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])? | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])? | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])? | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]> |
	<#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+> |
	<CHARACTER_LITERAL: "\'" (~["\'","\\","\n","\r"] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])? | ["0"-"3"] ["0"-"7"] ["0"-"7"])) "\'"> |
	<STRING_LITERAL: "\"" ( ~["\"","\\","\n","\r"] | "\\" ( ["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])?  | ["0"-"3"] ["0"-"7"] ["0"-"7"] | ( ["\n","\r"] | "\r\n")))* "\"">
}

/** 予約語と定数用のトークン */
TOKEN : {
	<CONTINUE: "continue"> |
	<VOLATILE: "volatile"> |
	<REGISTER: "register"> |
	<UNSIGNED: "unsigned"> |
	<TYPEDEF: "typedef"> |
	<DFLT: "default"> |
	<DOUBLE: "double"> |
	<SIZEOF: "sizeof"> |
	<SWITCH: "switch"> |
	<RETURN: "return"> |
	<EXTERN: "extern"> |
	<STRUCT: "struct"> |
	<STATIC: "static"> |
	<SIGNED: "signed"> |
	<WHILE: "while"> |
	<BREAK: "break"> |
	<UNION: "union"> |
	<CONST: "const"> |
	<FLOAT: "float"> |
	<SHORT: "short"> |
	<ELSE: "else"> |
	<CASE: "case"> |
	<LONG: "long"> |
	<ENUM: "enum"> |
	<AUTO: "auto"> |
	<VOID: "void"> |
	<CHAR: "char"> |
	<GOTO: "goto"> |
	<FOR: "for"> |
	<INT: "int"> |
	<IF: "if"> |
	<DO: "do">
}

/** 識別子用のトークン */
TOKEN : {
	<IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)*> |
	<#LETTER: ["$","A"-"Z","_","a"-"z"]> |
	<#DIGIT: ["0"-"9"]>
}

/** 演算子用のトークン */
TOKEN :
{
	< COMMA: ":" > |
	< QUESTION: "?" > |
	< ELLIPSIS: "..." > |
	< ASSIGN_EQ: "=" > |
	< MULT_EQ: "*=" > |
	< DIV_EQ: "/=" > |
	< MOD_EQ: "%=" > |
	< PLUS_EQ: "+=" > |
	< MINUS_EQ: "-=" > |
	< SHIFT_LEFT_EQ: "<<=" > |
	< SHIFT_RIGHT_EQ: ">>=" > |
	< BIT_AND_EQ: "&=" > |
	< BIT_XOR_EQ: "^=" > |
	< BIT_OR_EQ: "|=" > |
	< OR: "||" > |
	< AND: "&&" > |
	< BIT_OR: "|" > |
	< BIT_XOR: "^" > |
	< AMPERSAND: "&" > |
	< EQ: "==" > |
	< NOT_EQ: "!=" > |
	< LT: "<" > |
	< GT: ">" > |
	< LTE: "<=" > |
	< GTE: ">=" > |
	< SHIFT_LEFT: "<<" > |
	< SHIFT_RIGHT: ">>" > |
	< PLUS: "+" > |
	< MINUS: "-" > |
	< STAR: "*" > |
	< DIV: "/" > |
	< MOD: "%" > |
	< PLUSPLUS: "++" > |
	< MINUSMINUS: "--" > |
	< TILDE: "~" > |
	< NOT: "!" > |
	< DOT: "." > |
	< POINTERTO: "->" > |
	< DOTSTAR: ".*" > |
	< ARROWSTAR: "->*" >
}

/**************************************************
 * ここから下が文法(生成規則)
 **************************************************/
/** これが解析のエントリポイント */
ASTParse Parse() #Parse : {}
{
	(ExternalDeclaration())+
	{	printTypes();
		Log.i(TAG, "解析終了");
		return jjtThis;
	}
}

/** 外部宣言 */
void ExternalDeclaration() : {}
{
	// 関数宣言または宣言
	(	LOOKAHEAD( FunctionDefinition() ) FunctionDefinition() |
		Declaration() |
		";"
	)
}

/** 関数定義 */
void FunctionDefinition() : {}
{
	[LOOKAHEAD(DeclarationSpecifiers()) DeclarationSpecifiers()] Declarator() [ DeclarationList() ]
	CompoundStatement()
}

/** 宣言 */
void Declaration() : {}
{
	DeclarationSpecifiers() ( InitDeclaratorList() )? ";"
}

/** 宣言の種類(型)リスト */
void DeclarationList() : {}
{
	( LOOKAHEAD(Declaration()) Declaration() )+
}

/** 宣言のアクセス指定子 */
void DeclarationSpecifiers() : {}
{
	StorageClassSpecifier() [ LOOKAHEAD(DeclarationSpecifiers()) DeclarationSpecifiers() ] |
	TypeSpecifier()  [ LOOKAHEAD(DeclarationSpecifiers()) DeclarationSpecifiers() ] |
	TypeQualifier() [ LOOKAHEAD(DeclarationSpecifiers()) DeclarationSpecifiers() ]
}

/** 変数・型のアクセス指定子 */
void StorageClassSpecifier() : {}
{
	( <AUTO> | <REGISTER> | <STATIC> | <EXTERN> | <TYPEDEF>
		{
			typedefParsingStack.push(Boolean.TRUE);
		}
	)
}

/** 型の種類 */
void TypeSpecifier() : {}
{
	(	<VOID> | <CHAR> | <SHORT> | <INT> | <LONG> | <FLOAT> | <DOUBLE> | <SIGNED> |
		<UNSIGNED> | StructOrUnionSpecifier() | EnumSpecifier() | LOOKAHEAD( { isType(getToken(1).image) } )TypedefName()
	)
}

/** 型修飾子 */
void TypeQualifier() : {}
{
	( <CONST> | <VOLATILE> )
	{ Log.v(TAG, "定数型"); }
}

/** 構造体/ユニオンアクセス指定子 */
void StructOrUnionSpecifier() : {}
{
	{
		typedefParsingStack.push(Boolean.FALSE);
	}

	StructOrUnion() ( LOOKAHEAD(3) [ <IDENTIFIER> ] "{" StructDeclarationList() "}" | <IDENTIFIER> )

	{
		typedefParsingStack.pop();
	}
}

/** 構造体/ユニオン */
void StructOrUnion() : {}
{
	( <STRUCT> | <UNION> )
}

/** 構造体/ユニオン宣言リスト */
void StructDeclarationList() : {}
{
	( StructDeclaration() )+
}

/** 構造体/ユニオン宣言 */
void StructDeclaration() : {}
{
	SpecifierQualifierList() StructDeclaratorList() ";"
}

/** 構造体/ユニオンの定義内容リスト */
void StructDeclaratorList() : {}
{
	StructDeclarator() ( "," StructDeclarator() )*
}

/** 構造体/ユニオンの定義内容 */
void StructDeclarator() : {}
{
	( LOOKAHEAD(3) Declarator() | [ Declarator() ] ":" ConstantExpression() )
//	( Declarator() [ ":" ConstantExpression() ] | ":" ConstantExpression() )	// ビットフィールドアクセス時のエラー修正?
}

/** 初期化付き宣言リスト */
void InitDeclaratorList() : {}
{
	InitDeclarator() ("," InitDeclarator())*
	{
		// Finished with a typedefDeclaration??
		if(!(typedefParsingStack.empty()) && ((Boolean)typedefParsingStack.peek()).booleanValue()) {
			typedefParsingStack.pop();
		}
		Log.v(TAG, "初期化付き宣言リスト");
	}
}

/** 初期化付き宣言 */
void InitDeclarator() : {}
{
	Declarator() [ <ASSIGN_EQ> Initializer() ]
	{ Log.v(TAG, "初期化付き宣言"); }
}

/** アクセス指定子 */
void SpecifierQualifierList() : {}
{
	TypeSpecifier() [ LOOKAHEAD(SpecifierQualifierList()) SpecifierQualifierList() ] |
	TypeQualifier() [ LOOKAHEAD(SpecifierQualifierList()) SpecifierQualifierList() ]
}

/** 列挙型 */
void EnumSpecifier() : {}
{
	<ENUM> ( LOOKAHEAD(3) [ <IDENTIFIER> ] "{" EnumeratorList() "}" | <IDENTIFIER> )
}

/** 列挙型の宣言リスト */
void EnumeratorList() : {}
{
	Enumerator() ("," Enumerator())*
}

/** 列挙型のアイテム１つ分 */
void Enumerator() : {}
{
	<IDENTIFIER> [ <ASSIGN_EQ> ConstantExpression() ]
}

/** 宣言子 */
void Declarator() : {}
{
	[ Pointer() ] DirectDeclarator()
}

/** 直接宣言子 */
void DirectDeclarator() : { Token t;}
{
	// 識別子または関数呼び出し
	(	t = <IDENTIFIER>
		{
			if(!(typedefParsingStack.empty()) && ((Boolean)typedefParsingStack.peek()).booleanValue()) {
				addType(t.image);
			}
		} |
		"(" Declarator() ")"
	)

	{ typedefParsingStack.push( Boolean.FALSE ); }

	(	"[" [ ConstantExpression() ] "]" |
		LOOKAHEAD(3) "(" ParameterTypeList() ")" |
		"(" [ IdentifierList() ] ")"
	)*

	{ typedefParsingStack.pop(); }
}

/** ポインタ指定子 */
void Pointer() : {}
{
	<STAR> [ TypeQualifierList() ] [ Pointer() ]
}

/** 型指定子 */
void TypeQualifierList() : {}
{
	(TypeQualifier())+
}

/** パラメータタイプリスト */
void ParameterTypeList() : {}
{
	ParameterList() ["," "..." ]
}

/** パラメータ宣言リスト */
void ParameterList() : {}
{
	ParameterDeclaration() (LOOKAHEAD(2) "," ParameterDeclaration())*
}

/** パラメータ宣言 */
void ParameterDeclaration() : {}
{
	DeclarationSpecifiers()
	(	LOOKAHEAD(Declarator()) Declarator() |
		AbstractDeclarator()
	)
	(	<ASSIGN_EQ> AssignmentExpression() )?
}

/** 識別子リスト */
void IdentifierList() : {}
{
	<IDENTIFIER> ("," <IDENTIFIER>)*
}

/** イニシャライザリスト */
void InitializerList() : {}
{
	Initializer()
	(	LOOKAHEAD(2) "," Initializer() )*
}

/** イニシャライザ */
void Initializer() : {}
{
	"{" InitializerList() [","] "}" |
	AssignmentExpression()
}

/** 型名 */
void TypeName() : {}
{
	SpecifierQualifierList() [ AbstractDeclarator() ]
}

void AbstractDeclarator() : {}
{
	LOOKAHEAD(3) Pointer() |
	[ Pointer() ] DirectAbstractDeclarator()
}

void DirectAbstractDeclarator() : {}
{
	(	LOOKAHEAD(2) "(" AbstractDeclarator() ")" |
		"[" [ConstantExpression()] "]" |
		"(" [ParameterTypeList()] ")"
	)
	(	"[" [ ConstantExpression() ] "]" | "(" [ ParameterTypeList() ] ")"
	)*
}

/** typedef名 */
void TypedefName() : {}
{
	<IDENTIFIER>
}

/** 命令文リスト */
void StatementList() : {}
{
	(	LOOKAHEAD(Statement()) Statement() )+
}

/** 命令文 */
void Statement() : {}
{
	LOOKAHEAD( Declaration() ) Declaration() |
	LOOKAHEAD( Expression() ";" ) Expression() ";" |
	CompoundStatement() |
	SelectionStatement() |
	JumpStatement() |
	";" |
	LOOKAHEAD(2) LabeledStatement() |
	IterationStatement()
}

/** ラベル命令: */
void LabeledStatement() : {}
{
	(	<IDENTIFIER> ":" Statement() |
		<CASE> ConstantExpression() ":" Statement() |
		<DFLT> ":" Statement()
	)
}

/** 複命令文 */
void CompoundStatement() : {}
{
	"{"
    (	StatementList() )?
	"}"
}

/** 選択命令文 */
void SelectionStatement() : {}
{
	(	<IF> "(" Expression() ")" Statement() [ LOOKAHEAD(2) <ELSE> Statement() ] |
		<SWITCH> "(" Expression() ")" Statement()
	)
}

/** 列挙命令 */
void IterationStatement() : {}
{
	(	<WHILE> "(" Expression() ")" Statement() |
		<DO> Statement() <WHILE> "(" Expression() ")" ";" |
		<FOR> "(" ( LOOKAHEAD(3) Declaration() | Expression() ";" | ";")
			( Expression() )? ";" ( Expression() )? ")" Statement()
	)
}

/** ジャンプ命令 */
void JumpStatement() : {}
{
	(	<GOTO> <IDENTIFIER> ";" |
		<CONTINUE> ";" |
		<BREAK> ";" |
		<RETURN> ( Expression() )? ";"
	)
}

/** 式 */
void Expression() : {}
{
	AssignmentExpression() ( LOOKAHEAD(2) "," AssignmentExpression() )*
}

/**  代入式 */
void AssignmentExpression() : {}
{
	ConditionalExpression()
	(	AssignmentOperator()
		AssignmentExpression()
	)?
}

/** 代入演算子 */
void AssignmentOperator() : {}
{
	(	<ASSIGN_EQ> |
		<MULT_EQ> |
		<DIV_EQ> |
		<MOD_EQ> |
		<PLUS_EQ> |
		<MINUS_EQ> |
		<SHIFT_LEFT_EQ> |
		<SHIFT_RIGHT_EQ> |
		<BIT_AND_EQ> |
		<BIT_XOR_EQ> |
		<BIT_OR_EQ> )
}

/** 比較演算式 */
void ConditionalExpression() : {}
{
	LogicalORExpression()
	(	<QUESTION> ConditionalExpression() <COMMA> ConditionalExpression() #Conditional(3) )?
}

/** 定数式 */
void ConstantExpression() : {}
{
	ConditionalExpression() #Constant(1)
}

/** 論理和式 */
void LogicalORExpression() : {}
{
	LogicalANDExpression()
	(	<OR> LogicalANDExpression() #LogicalOR(2) )*
}

/** 論理積式 */
void LogicalANDExpression() : {}
{
	InclusiveORExpression()
	(	<AND> InclusiveORExpression() #LogicalAND(2) )*
}

/** ビット論理和式 */
void InclusiveORExpression() : {}
{
	ExclusiveORExpression()
	(	<BIT_OR> ExclusiveORExpression() #InclusiveOR(2) )*
}

/** 排他的ビット論理和 */
void ExclusiveORExpression() : {}
{
	ANDExpression()
	(	<BIT_XOR> ANDExpression() #ExclusiveOR(2) )*
}

/** ビット論理積式 */
void ANDExpression() : {}
{
	EqualityExpression()
	(	LOOKAHEAD(2) <AMPERSAND> EqualityExpression() #And(2) )*
}

/** 比較演算式 */
void EqualityExpression() : { Token t; }
{
	RelationalExpression()
	(	<EQ> RelationalExpression() #Equality(2) |
		<NOT_EQ> RelationalExpression() #NotEquality(2)
	)*
}

/** 比較演算式 */
void RelationalExpression() : { Token t; }
{
	ShiftExpression()
	(	LOOKAHEAD(2) (
			<LT> ShiftExpression() #RelationalLT(2) |
			<GT> ShiftExpression() #RelationalGT(2) |
			<LTE> ShiftExpression() #RelationalLTE(2) |
			<GTE> ShiftExpression() #RelationalGTE(2)
		)
	)*
}

/** シフト演算式 */
void ShiftExpression() : { Token t; }
{
	AdditiveExpression()
	(	<SHIFT_LEFT> AdditiveExpression() #ShiftLeft(2) |
		<SHIFT_RIGHT> AdditiveExpression() #ShiftRight(2)
	)*
}

/** 算術和/算術差式 */
void AdditiveExpression() : { Token t; }
{
	MultiplicativeExpression()
	(	LOOKAHEAD(2) (
			t=<PLUS> MultiplicativeExpression() #AdditivePlus(2) |
			t=<MINUS> MultiplicativeExpression() #AdditiveMinus(2)
		)
	)*
}

/** 算術除積式 */
void MultiplicativeExpression() : { Token t; }
{
	PmExpression()
	(	LOOKAHEAD(2) ( <STAR> | <DIV> | <MOD> ) PmExpression() #Multiplicative(2) )*
}

/** ポインタ参照式 */
void PmExpression() : { Token t; }
{
    CastExpression()
    (	( <DOTSTAR> | <ARROWSTAR> )
    	CastExpression()
    )*
}

/** キャスト演算式 */
void CastExpression() : { Token t; }
{
	LOOKAHEAD( "(" TypeName() ")" ) "(" TypeName() ")" CastExpression() |
	UnaryExpression()
}

/** 単項演算式 */
void UnaryExpression() : {}
{
	<PLUSPLUS> UnaryExpression() |
	<MINUSMINUS> UnaryExpression() |
	LOOKAHEAD(3) UnaryOperator() CastExpression() |
	<SIZEOF> (
		LOOKAHEAD( "(" TypeName() ")" ) "(" TypeName() ")" |
		UnaryExpression()
	) |
	PostfixExpression()
}

/** 単項演算子 */
void UnaryOperator() : { Token t; }
{
	(	<AMPERSAND> |
		<STAR> |
		<PLUS> |
		<MINUS> |
		<TILDE> |
		<NOT>
	)
}

/** 後置演算式 */
void PostfixExpression() : { Token t; }
{
	LOOKAHEAD(3) PrimaryExpression()
	(	LOOKAHEAD(2) (
			"[" Expression() "]" |
			"(" ( ArgumentExpressionList() )? ")" |
			"." <IDENTIFIER> |
			<POINTERTO> <IDENTIFIER> |
			<PLUSPLUS> |
			<MINUSMINUS>
		)
	)* |
	TypeSpecifier() "(" ( ArgumentExpressionList() )? ")"
}

/** 優先演算式 */
void PrimaryExpression() : {}
{
	(	<IDENTIFIER> |
		Constant() |
		"(" Expression() ")"
	)
}

/** 引数式リスト */
void ArgumentExpressionList() : {}
{
	AssignmentExpression()
	(	"," AssignmentExpression() )*
}

void Identifier() #Identifier : { Token t;}
{
	t=<IDENTIFIER> { jjtThis.setName(t.image); }
}

/** 定数 */
void Constant() : { Token t; }
{
	t=<INTEGER_LITERAL> {
		jjtThis.jjtSetValue(t.image);
	} #IntegerConst |
	t=<FLOATING_POINT_LITERAL> {
		jjtThis.jjtSetValue(t.image);
	} #FloatConst |
	t=<CHARACTER_LITERAL> {
		jjtThis.jjtSetValue(t.image);
	} #CharConst |
	t=<STRING_LITERAL> {
		jjtThis.jjtSetValue(t.image);
	} #StringConst
}
